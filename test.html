<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Green Barrier on Canvas</title>
    <style>
        canvas {
            border: 1px solid black;
        }
    </style>
</head>
<body>
<canvas id="myCanvas" width="800" height="800"></canvas>
<script>
    const projectiles = [];
    const maxProjectiles = 20;
    const projectileSpeed = 2;
    const barriers = [];
    const explosions = [];

    class ParticleExplosion {
        constructor(x, y, radius, numParticles) {
            this.x = x;
            this.y = y;
            this.radius = radius;
            this.numParticles = numParticles;
            this.particles = this.createParticles();
            this.timer = 0;
            this.duration = 250;
        }

        createParticles() {
            const particles = [];
            for (let i = 0; i < this.numParticles; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 0.01 + Math.random() * 0.6;
                const vx = Math.cos(angle) * speed;
                const vy = Math.sin(angle) * speed;
                const particle = {
                    x: this.x,
                    y: this.y,
                    vx: vx,
                    vy: vy,
                    size: Math.random() * 3,
                    alpha: 1
                };
                particles.push(particle);
            }
            return particles;
        }

        update() {
            this.timer++;
            this.particles.forEach(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.alpha -= 0.01;
            });
        }

        draw(ctx) {
            this.particles.forEach(particle => {
                ctx.fillStyle = Math.random() < 0.5 ? 'white' : 'orange';
                ctx.globalAlpha = Math.max(particle.alpha, 0);
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                ctx.closePath();
                ctx.fill();
            });
            ctx.globalAlpha = 1;
        }

        isDone() {
            return this.timer >= this.duration;
        }
    }

    class Projectile {
        constructor(x, y, width, height, speed) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            this.speed = speed;
        }

        update() {
            this.y += this.speed;
        }

        draw(ctx) {
            ctx.fillStyle = 'red';
            ctx.fillRect(this.x, this.y, this.width, this.height);
        }
    }

    class Barrier {
        constructor(x, y, blockSize, blockCountX, blockCountY) {
            this.x = x;
            this.y = y;
            this.blockSize = blockSize;
            this.blockCountX = blockCountX;
            this.blockCountY = blockCountY;
            this.barrierRight = this.x + this.blockSize * this.blockCountX;
            this.barrierBottom = this.y + this.blockSize * this.blockCountY;
            this.blocks = this.createBlocks();
        }

        createBlocks() {
            const blocks = [];
            for (let i = 0; i < this.blockCountX; i++) {
                blocks[i] = [];
                for (let j = 0; j < this.blockCountY; j++) {
                    const blockX = this.x + i * this.blockSize;
                    const blockY = this.y + j * this.blockSize;
                    const blockRight = blockX + this.blockSize;
                    const blockBottom = blockY + this.blockSize;

                    // Calculate the percentage of removed blocks
                    const remove60Percent = Math.ceil(this.blockCountX * 0.6 / 2);
                    const remove40Percent = Math.ceil(this.blockCountX * 0.4 / 2);
                    const removeRow3Percent = Math.ceil(this.blockCountY * 0.2);
                    const removeRow2Percent = Math.ceil(this.blockCountY * 0.1);
                    const removeRow1Percent = Math.ceil(this.blockCountY * 0.05);

                    const visible = !(
                        (i >= (this.blockCountX / 2) - remove60Percent && i < (this.blockCountX / 2) + remove60Percent && (j === this.blockCountY - 1 || j === this.blockCountY - 2)) ||
                        (i >= (this.blockCountX / 2) - remove40Percent && i < (this.blockCountX / 2) + remove40Percent && j === this.blockCountY - 3) ||
                        (j < removeRow3Percent && (i === 0 || i === this.blockCountX - 1)) ||
                        (j < removeRow2Percent && (i === 1 || i === this.blockCountX - 2)) ||
                        (j < removeRow1Percent && (i === 2 || i === this.blockCountX - 3))
                    );

                    blocks[i][j] = {
                        x: blockX,
                        y: blockY,
                        width: this.blockSize,
                        height: this.blockSize,
                        right: blockRight,
                        bottom: blockBottom,
                        visible: visible
                    };
                }
            }
            return blocks;
        }

        draw(ctx) {
            ctx.fillStyle = 'green';
            for (let i = 0; i < this.blockCountX; i++) {
                for (let j = 0; j < this.blockCountY; j++) {
                    const block = this.blocks[i][j];
                    if (block.visible) {
                        ctx.fillRect(block.x, block.y, block.width, block.height);
                    }
                }
            }
        }

        isProjectileInBounds(projectile) {
            return projectile.x + projectile.width > this.x &&
                projectile.x < this.barrierRight &&
                projectile.y + projectile.height > this.y &&
                projectile.y < this.barrierBottom;
        }

        collisionDetection(rect) {
            for (let i = 0; i < this.blockCountX; i++) {
                for (let j = 0; j < this.blockCountY; j++) {
                    const block = this.blocks[i][j];
                    if (block.visible &&
                        rect.x < block.x + block.width &&
                        rect.x + rect.width > block.x &&
                        rect.y < block.y + block.height &&
                        rect.y + rect.height > block.y) {
                        this.explodeBlocks(i, j);
                        return true;
                    }
                }
            }
            return false;
        }

        explodeBlocks(blockX, blockY) {
            // Remove the matching block
            this.blocks[blockX][blockY].visible = false;

            // Define a helper function to remove blocks with a given probability
            const removeBlockWithProbability = (x, y) => {
                if (this.blocks[x] && this.blocks[x][y] && this.blocks[x][y].visible) {
                    this.blocks[x][y].visible = false;
                }
            };

            // Iterate through radii 1 to 5
            for (let radius = 0; radius <= 5; radius++) {
                // Remove 5 random blocks for the current radius
                for (let i = 0; i < 30 + (radius * 2); i++) {
                    // Calculate a random angle and use the current radius as distance
                    const angle = Math.random() * 2 * Math.PI;

                    // Calculate the block coordinates using polar coordinates
                    const x = blockX + Math.round(radius * Math.cos(angle));
                    const y = blockY + Math.round(radius * Math.sin(angle));

                    // Remove the block with a probability of 1 (since we want to remove the selected block)
                    removeBlockWithProbability(x, y);
                }
            }
        }
    }

    const canvas = document.getElementById('myCanvas');
    const ctx = canvas.getContext('2d');

    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const blockSize = 3;
    const blockCountX = 40;
    const blockCountY = 24;

    const barrierMargin = (canvas.width - (blockSize * blockCountX) * 4 - 80 * 3) / 2;

    for (let i = 0; i < 4; i++) {
        const barrierX = barrierMargin + i * (blockSize * blockCountX + 80);
        const barrier = new Barrier(barrierX, centerY - (blockSize * blockCountY) / 2, blockSize, blockCountX, blockCountY);
        barriers.push(barrier);
    }

    barriers.forEach(barrier => barrier.draw(ctx));

    function update() {

        // Update projectiles
        projectiles.forEach(projectile => projectile.update());

        // Update explosions
        explosions.forEach(explosion => explosion.update());

        // Add new projectiles randomly
        if (projectiles.length < maxProjectiles && Math.random() < 0.05) {
            const x = Math.random() * 800;
            const y = 0;
            const width = 4;
            const height = 10;
            const projectile = new Projectile(x, y, width, height, projectileSpeed);
            projectiles.push(projectile);
        }

        // Check for collisions
        projectiles.forEach((projectile, index) => {
            barriers.forEach((barrier, bIndex) => {
                if (barrier.collisionDetection(projectile)) {
                    // Create an explosion on collision
                    const explosion = new ParticleExplosion(projectile.x + (projectile.width/2.0), projectile.y + projectile.height, 100,50);
                    explosions.push(explosion);

                    // Remove the projectile on collision
                    projectiles.splice(index, 1);
                }
            });
        });

        // Remove projectiles that reached the bottom
        projectiles.forEach((projectile, index) => {
            if (projectile.y > canvas.height) {
                // Create an explosion at the bottom
                const explosion = new ParticleExplosion(projectile.x, projectile.y, 25, 25);
                explosions.push(explosion);

                // Remove the projectile
                projectiles.splice(index, 1);
            }
        });

        // Remove finished explosions
        explosions.forEach((explosion, index) => {
            if (explosion.isDone()) {
                explosions.splice(index, 1);
            }
        });

        // Draw everything
        //ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        barriers.forEach(barrier => barrier.draw(ctx));
        projectiles.forEach(projectile => projectile.draw(ctx));
        explosions.forEach(explosion => explosion.draw(ctx));

        requestAnimationFrame(update);
    }

    update();

</script>
</body>
</html>
